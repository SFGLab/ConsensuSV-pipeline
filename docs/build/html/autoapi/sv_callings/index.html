<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>sv_callings &mdash; ConsensuSV-pipeline 1.1 documentation</title><link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../../_static/graphviz.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  <script id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
        <script src="../../_static/jquery.js"></script>
        <script src="../../_static/underscore.js"></script>
        <script src="../../_static/doctools.js"></script>
        <script src="../../_static/language_data.js"></script>
    <script src="../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="../../index.html" class="icon icon-home"> ConsensuSV-pipeline
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../index.html">API Reference</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">ConsensuSV-pipeline</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../index.html" class="icon icon-home"></a> &raquo;</li>
      <li><code class="xref py py-mod docutils literal notranslate"><span class="pre">sv_callings</span></code></li>
      <li class="wy-breadcrumbs-aside">
            <a href="../../_sources/autoapi/sv_callings/index.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <div class="section" id="module-sv_callings">
<span id="sv-callings"></span><h1><a class="reference internal" href="#module-sv_callings" title="sv_callings"><code class="xref py py-mod docutils literal notranslate"><span class="pre">sv_callings</span></code></a><a class="headerlink" href="#module-sv_callings" title="Permalink to this headline">¶</a></h1>
<div class="section" id="module-contents">
<h2>Module Contents<a class="headerlink" href="#module-contents" title="Permalink to this headline">¶</a></h2>
<div class="section" id="classes">
<h3>Classes<a class="headerlink" href="#classes" title="Permalink to this headline">¶</a></h3>
<table class="longtable docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#sv_callings.SNPCalling" title="sv_callings.SNPCalling"><code class="xref py py-obj docutils literal notranslate"><span class="pre">SNPCalling</span></code></a></p></td>
<td><p>Class responsible for SNP calling using bcftools.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#sv_callings.IndelCalling" title="sv_callings.IndelCalling"><code class="xref py py-obj docutils literal notranslate"><span class="pre">IndelCalling</span></code></a></p></td>
<td><p>Class responsible for Indel calling using bcftools.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#sv_callings.SVDelly" title="sv_callings.SVDelly"><code class="xref py py-obj docutils literal notranslate"><span class="pre">SVDelly</span></code></a></p></td>
<td><p>Class responsible for SV calling using Delly.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#sv_callings.SVBreakdancer" title="sv_callings.SVBreakdancer"><code class="xref py py-obj docutils literal notranslate"><span class="pre">SVBreakdancer</span></code></a></p></td>
<td><p>Class responsible for SV calling using Breakdancer.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#sv_callings.SVTardis" title="sv_callings.SVTardis"><code class="xref py py-obj docutils literal notranslate"><span class="pre">SVTardis</span></code></a></p></td>
<td><p>Class responsible for SV calling using Tardis.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#sv_callings.SVNovoBreak" title="sv_callings.SVNovoBreak"><code class="xref py py-obj docutils literal notranslate"><span class="pre">SVNovoBreak</span></code></a></p></td>
<td><p>Class responsible for SV calling using novoBreak. It is disabled in default run because of its computational time.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#sv_callings.SVCNVNator" title="sv_callings.SVCNVNator"><code class="xref py py-obj docutils literal notranslate"><span class="pre">SVCNVNator</span></code></a></p></td>
<td><p>Class responsible for SV calling using CNVNator.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#sv_callings.SVBreakSeq" title="sv_callings.SVBreakSeq"><code class="xref py py-obj docutils literal notranslate"><span class="pre">SVBreakSeq</span></code></a></p></td>
<td><p>Class responsible for SV calling using BreakSeq.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#sv_callings.SVManta" title="sv_callings.SVManta"><code class="xref py py-obj docutils literal notranslate"><span class="pre">SVManta</span></code></a></p></td>
<td><p>Class responsible for SV calling using Manta.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#sv_callings.SVLumpy" title="sv_callings.SVLumpy"><code class="xref py py-obj docutils literal notranslate"><span class="pre">SVLumpy</span></code></a></p></td>
<td><p>Class responsible for SV calling using Lumpy.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#sv_callings.SVWhamg" title="sv_callings.SVWhamg"><code class="xref py py-obj docutils literal notranslate"><span class="pre">SVWhamg</span></code></a></p></td>
<td><p>Class responsible for SV calling using Whamg.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#sv_callings.SVSvelter" title="sv_callings.SVSvelter"><code class="xref py py-obj docutils literal notranslate"><span class="pre">SVSvelter</span></code></a></p></td>
<td><p>Class responsible for SV calling using Svelter.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#sv_callings.CallVariants" title="sv_callings.CallVariants"><code class="xref py py-obj docutils literal notranslate"><span class="pre">CallVariants</span></code></a></p></td>
<td><p>Class responsible for calling variants using various methods.</p></td>
</tr>
</tbody>
</table>
<dl class="py class">
<dt id="sv_callings.SNPCalling">
<em class="property">class </em><code class="sig-prename descclassname">sv_callings.</code><code class="sig-name descname">SNPCalling</code><span class="sig-paren">(</span><em class="sig-param"><span class="o">*</span><span class="n">args</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="headerlink" href="#sv_callings.SNPCalling" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-obj docutils literal notranslate"><span class="pre">luigi.Task</span></code></p>
<p>Class responsible for SNP calling using bcftools.</p>
<dl class="py attribute">
<dt id="sv_callings.SNPCalling.resources">
<code class="sig-name descname">resources</code><a class="headerlink" href="#sv_callings.SNPCalling.resources" title="Permalink to this definition">¶</a></dt>
<dd><p>Resources used by the task.</p>
</dd></dl>

<dl class="py attribute">
<dt id="sv_callings.SNPCalling.working_dir">
<code class="sig-name descname">working_dir</code><a class="headerlink" href="#sv_callings.SNPCalling.working_dir" title="Permalink to this definition">¶</a></dt>
<dd><p>Working directory of the task.</p>
</dd></dl>

<dl class="py attribute">
<dt id="sv_callings.SNPCalling.file_name_1">
<code class="sig-name descname">file_name_1</code><a class="headerlink" href="#sv_callings.SNPCalling.file_name_1" title="Permalink to this definition">¶</a></dt>
<dd><p>Name of the file containing R1 reads.</p>
</dd></dl>

<dl class="py attribute">
<dt id="sv_callings.SNPCalling.file_name_2">
<code class="sig-name descname">file_name_2</code><a class="headerlink" href="#sv_callings.SNPCalling.file_name_2" title="Permalink to this definition">¶</a></dt>
<dd><p>Name of the file containing R2 reads.</p>
</dd></dl>

<dl class="py attribute">
<dt id="sv_callings.SNPCalling.sample_name">
<code class="sig-name descname">sample_name</code><a class="headerlink" href="#sv_callings.SNPCalling.sample_name" title="Permalink to this definition">¶</a></dt>
<dd><p>Name of the sample.</p>
</dd></dl>

<dl class="py attribute">
<dt id="sv_callings.SNPCalling.train_1000g">
<code class="sig-name descname">train_1000g</code><a class="headerlink" href="#sv_callings.SNPCalling.train_1000g" title="Permalink to this definition">¶</a></dt>
<dd><p>Information whether the current task is part of 1000G benchmarking pipeline.</p>
</dd></dl>

<dl class="py method">
<dt id="sv_callings.SNPCalling.requires">
<code class="sig-name descname">requires</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em><span class="sig-paren">)</span><a class="headerlink" href="#sv_callings.SNPCalling.requires" title="Permalink to this definition">¶</a></dt>
<dd><p>The Tasks that this Task depends on.</p>
<p>A Task will only run if all of the Tasks that it requires are completed.
If your Task does not require any other Tasks, then you don’t need to
override this method. Otherwise, a subclass can override this method
to return a single Task, a list of Task instances, or a dict whose
values are Task instances.</p>
<p>See <span class="xref std std-ref">Task.requires</span></p>
</dd></dl>

<dl class="py method">
<dt id="sv_callings.SNPCalling.output">
<code class="sig-name descname">output</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em><span class="sig-paren">)</span><a class="headerlink" href="#sv_callings.SNPCalling.output" title="Permalink to this definition">¶</a></dt>
<dd><p>The output that this Task produces.</p>
<p>The output of the Task determines if the Task needs to be run–the task
is considered finished iff the outputs all exist. Subclasses should
override this method to return a single <code class="xref py py-class docutils literal notranslate"><span class="pre">Target</span></code> or a list of
<code class="xref py py-class docutils literal notranslate"><span class="pre">Target</span></code> instances.</p>
<dl class="simple">
<dt>Implementation note</dt><dd><p>If running multiple workers, the output must be a resource that is accessible
by all workers, such as a DFS or database. Otherwise, workers might compute
the same output since they don’t see the work done by other workers.</p>
</dd>
</dl>
<p>See <span class="xref std std-ref">Task.output</span></p>
</dd></dl>

<dl class="py method">
<dt id="sv_callings.SNPCalling.run">
<code class="sig-name descname">run</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em><span class="sig-paren">)</span><a class="headerlink" href="#sv_callings.SNPCalling.run" title="Permalink to this definition">¶</a></dt>
<dd><p>The task run method, to be overridden in a subclass.</p>
<p>See <span class="xref std std-ref">Task.run</span></p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="sv_callings.IndelCalling">
<em class="property">class </em><code class="sig-prename descclassname">sv_callings.</code><code class="sig-name descname">IndelCalling</code><span class="sig-paren">(</span><em class="sig-param"><span class="o">*</span><span class="n">args</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="headerlink" href="#sv_callings.IndelCalling" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-obj docutils literal notranslate"><span class="pre">luigi.Task</span></code></p>
<p>Class responsible for Indel calling using bcftools.</p>
<dl class="py attribute">
<dt id="sv_callings.IndelCalling.resources">
<code class="sig-name descname">resources</code><a class="headerlink" href="#sv_callings.IndelCalling.resources" title="Permalink to this definition">¶</a></dt>
<dd><p>Resources used by the task.</p>
</dd></dl>

<dl class="py attribute">
<dt id="sv_callings.IndelCalling.working_dir">
<code class="sig-name descname">working_dir</code><a class="headerlink" href="#sv_callings.IndelCalling.working_dir" title="Permalink to this definition">¶</a></dt>
<dd><p>Working directory of the task.</p>
</dd></dl>

<dl class="py attribute">
<dt id="sv_callings.IndelCalling.file_name_1">
<code class="sig-name descname">file_name_1</code><a class="headerlink" href="#sv_callings.IndelCalling.file_name_1" title="Permalink to this definition">¶</a></dt>
<dd><p>Name of the file containing R1 reads.</p>
</dd></dl>

<dl class="py attribute">
<dt id="sv_callings.IndelCalling.file_name_2">
<code class="sig-name descname">file_name_2</code><a class="headerlink" href="#sv_callings.IndelCalling.file_name_2" title="Permalink to this definition">¶</a></dt>
<dd><p>Name of the file containing R2 reads.</p>
</dd></dl>

<dl class="py attribute">
<dt id="sv_callings.IndelCalling.sample_name">
<code class="sig-name descname">sample_name</code><a class="headerlink" href="#sv_callings.IndelCalling.sample_name" title="Permalink to this definition">¶</a></dt>
<dd><p>Name of the sample.</p>
</dd></dl>

<dl class="py attribute">
<dt id="sv_callings.IndelCalling.train_1000g">
<code class="sig-name descname">train_1000g</code><a class="headerlink" href="#sv_callings.IndelCalling.train_1000g" title="Permalink to this definition">¶</a></dt>
<dd><p>Information whether the current task is part of 1000G benchmarking pipeline.</p>
</dd></dl>

<dl class="py method">
<dt id="sv_callings.IndelCalling.requires">
<code class="sig-name descname">requires</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em><span class="sig-paren">)</span><a class="headerlink" href="#sv_callings.IndelCalling.requires" title="Permalink to this definition">¶</a></dt>
<dd><p>The Tasks that this Task depends on.</p>
<p>A Task will only run if all of the Tasks that it requires are completed.
If your Task does not require any other Tasks, then you don’t need to
override this method. Otherwise, a subclass can override this method
to return a single Task, a list of Task instances, or a dict whose
values are Task instances.</p>
<p>See <span class="xref std std-ref">Task.requires</span></p>
</dd></dl>

<dl class="py method">
<dt id="sv_callings.IndelCalling.output">
<code class="sig-name descname">output</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em><span class="sig-paren">)</span><a class="headerlink" href="#sv_callings.IndelCalling.output" title="Permalink to this definition">¶</a></dt>
<dd><p>The output that this Task produces.</p>
<p>The output of the Task determines if the Task needs to be run–the task
is considered finished iff the outputs all exist. Subclasses should
override this method to return a single <code class="xref py py-class docutils literal notranslate"><span class="pre">Target</span></code> or a list of
<code class="xref py py-class docutils literal notranslate"><span class="pre">Target</span></code> instances.</p>
<dl class="simple">
<dt>Implementation note</dt><dd><p>If running multiple workers, the output must be a resource that is accessible
by all workers, such as a DFS or database. Otherwise, workers might compute
the same output since they don’t see the work done by other workers.</p>
</dd>
</dl>
<p>See <span class="xref std std-ref">Task.output</span></p>
</dd></dl>

<dl class="py method">
<dt id="sv_callings.IndelCalling.run">
<code class="sig-name descname">run</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em><span class="sig-paren">)</span><a class="headerlink" href="#sv_callings.IndelCalling.run" title="Permalink to this definition">¶</a></dt>
<dd><p>The task run method, to be overridden in a subclass.</p>
<p>See <span class="xref std std-ref">Task.run</span></p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="sv_callings.SVDelly">
<em class="property">class </em><code class="sig-prename descclassname">sv_callings.</code><code class="sig-name descname">SVDelly</code><span class="sig-paren">(</span><em class="sig-param"><span class="o">*</span><span class="n">args</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="headerlink" href="#sv_callings.SVDelly" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-obj docutils literal notranslate"><span class="pre">luigi.Task</span></code></p>
<p>Class responsible for SV calling using Delly.</p>
<dl class="py attribute">
<dt id="sv_callings.SVDelly.resources">
<code class="sig-name descname">resources</code><a class="headerlink" href="#sv_callings.SVDelly.resources" title="Permalink to this definition">¶</a></dt>
<dd><p>Resources used by the task.</p>
</dd></dl>

<dl class="py attribute">
<dt id="sv_callings.SVDelly.working_dir">
<code class="sig-name descname">working_dir</code><a class="headerlink" href="#sv_callings.SVDelly.working_dir" title="Permalink to this definition">¶</a></dt>
<dd><p>Working directory of the task.</p>
</dd></dl>

<dl class="py attribute">
<dt id="sv_callings.SVDelly.file_name_1">
<code class="sig-name descname">file_name_1</code><a class="headerlink" href="#sv_callings.SVDelly.file_name_1" title="Permalink to this definition">¶</a></dt>
<dd><p>Name of the file containing R1 reads.</p>
</dd></dl>

<dl class="py attribute">
<dt id="sv_callings.SVDelly.file_name_2">
<code class="sig-name descname">file_name_2</code><a class="headerlink" href="#sv_callings.SVDelly.file_name_2" title="Permalink to this definition">¶</a></dt>
<dd><p>Name of the file containing R2 reads.</p>
</dd></dl>

<dl class="py attribute">
<dt id="sv_callings.SVDelly.sample_name">
<code class="sig-name descname">sample_name</code><a class="headerlink" href="#sv_callings.SVDelly.sample_name" title="Permalink to this definition">¶</a></dt>
<dd><p>Name of the sample.</p>
</dd></dl>

<dl class="py attribute">
<dt id="sv_callings.SVDelly.train_1000g">
<code class="sig-name descname">train_1000g</code><a class="headerlink" href="#sv_callings.SVDelly.train_1000g" title="Permalink to this definition">¶</a></dt>
<dd><p>Information whether the current task is part of 1000G benchmarking pipeline.</p>
</dd></dl>

<dl class="py method">
<dt id="sv_callings.SVDelly.requires">
<code class="sig-name descname">requires</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em><span class="sig-paren">)</span><a class="headerlink" href="#sv_callings.SVDelly.requires" title="Permalink to this definition">¶</a></dt>
<dd><p>The Tasks that this Task depends on.</p>
<p>A Task will only run if all of the Tasks that it requires are completed.
If your Task does not require any other Tasks, then you don’t need to
override this method. Otherwise, a subclass can override this method
to return a single Task, a list of Task instances, or a dict whose
values are Task instances.</p>
<p>See <span class="xref std std-ref">Task.requires</span></p>
</dd></dl>

<dl class="py method">
<dt id="sv_callings.SVDelly.output">
<code class="sig-name descname">output</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em><span class="sig-paren">)</span><a class="headerlink" href="#sv_callings.SVDelly.output" title="Permalink to this definition">¶</a></dt>
<dd><p>The output that this Task produces.</p>
<p>The output of the Task determines if the Task needs to be run–the task
is considered finished iff the outputs all exist. Subclasses should
override this method to return a single <code class="xref py py-class docutils literal notranslate"><span class="pre">Target</span></code> or a list of
<code class="xref py py-class docutils literal notranslate"><span class="pre">Target</span></code> instances.</p>
<dl class="simple">
<dt>Implementation note</dt><dd><p>If running multiple workers, the output must be a resource that is accessible
by all workers, such as a DFS or database. Otherwise, workers might compute
the same output since they don’t see the work done by other workers.</p>
</dd>
</dl>
<p>See <span class="xref std std-ref">Task.output</span></p>
</dd></dl>

<dl class="py method">
<dt id="sv_callings.SVDelly.run">
<code class="sig-name descname">run</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em><span class="sig-paren">)</span><a class="headerlink" href="#sv_callings.SVDelly.run" title="Permalink to this definition">¶</a></dt>
<dd><p>The task run method, to be overridden in a subclass.</p>
<p>See <span class="xref std std-ref">Task.run</span></p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="sv_callings.SVBreakdancer">
<em class="property">class </em><code class="sig-prename descclassname">sv_callings.</code><code class="sig-name descname">SVBreakdancer</code><span class="sig-paren">(</span><em class="sig-param"><span class="o">*</span><span class="n">args</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="headerlink" href="#sv_callings.SVBreakdancer" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-obj docutils literal notranslate"><span class="pre">luigi.Task</span></code></p>
<p>Class responsible for SV calling using Breakdancer.</p>
<dl class="py attribute">
<dt id="sv_callings.SVBreakdancer.resources">
<code class="sig-name descname">resources</code><a class="headerlink" href="#sv_callings.SVBreakdancer.resources" title="Permalink to this definition">¶</a></dt>
<dd><p>Resources used by the task.</p>
</dd></dl>

<dl class="py attribute">
<dt id="sv_callings.SVBreakdancer.working_dir">
<code class="sig-name descname">working_dir</code><a class="headerlink" href="#sv_callings.SVBreakdancer.working_dir" title="Permalink to this definition">¶</a></dt>
<dd><p>Working directory of the task.</p>
</dd></dl>

<dl class="py attribute">
<dt id="sv_callings.SVBreakdancer.file_name_1">
<code class="sig-name descname">file_name_1</code><a class="headerlink" href="#sv_callings.SVBreakdancer.file_name_1" title="Permalink to this definition">¶</a></dt>
<dd><p>Name of the file containing R1 reads.</p>
</dd></dl>

<dl class="py attribute">
<dt id="sv_callings.SVBreakdancer.file_name_2">
<code class="sig-name descname">file_name_2</code><a class="headerlink" href="#sv_callings.SVBreakdancer.file_name_2" title="Permalink to this definition">¶</a></dt>
<dd><p>Name of the file containing R2 reads.</p>
</dd></dl>

<dl class="py attribute">
<dt id="sv_callings.SVBreakdancer.sample_name">
<code class="sig-name descname">sample_name</code><a class="headerlink" href="#sv_callings.SVBreakdancer.sample_name" title="Permalink to this definition">¶</a></dt>
<dd><p>Name of the sample.</p>
</dd></dl>

<dl class="py attribute">
<dt id="sv_callings.SVBreakdancer.train_1000g">
<code class="sig-name descname">train_1000g</code><a class="headerlink" href="#sv_callings.SVBreakdancer.train_1000g" title="Permalink to this definition">¶</a></dt>
<dd><p>Information whether the current task is part of 1000G benchmarking pipeline.</p>
</dd></dl>

<dl class="py method">
<dt id="sv_callings.SVBreakdancer.requires">
<code class="sig-name descname">requires</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em><span class="sig-paren">)</span><a class="headerlink" href="#sv_callings.SVBreakdancer.requires" title="Permalink to this definition">¶</a></dt>
<dd><p>The Tasks that this Task depends on.</p>
<p>A Task will only run if all of the Tasks that it requires are completed.
If your Task does not require any other Tasks, then you don’t need to
override this method. Otherwise, a subclass can override this method
to return a single Task, a list of Task instances, or a dict whose
values are Task instances.</p>
<p>See <span class="xref std std-ref">Task.requires</span></p>
</dd></dl>

<dl class="py method">
<dt id="sv_callings.SVBreakdancer.output">
<code class="sig-name descname">output</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em><span class="sig-paren">)</span><a class="headerlink" href="#sv_callings.SVBreakdancer.output" title="Permalink to this definition">¶</a></dt>
<dd><p>The output that this Task produces.</p>
<p>The output of the Task determines if the Task needs to be run–the task
is considered finished iff the outputs all exist. Subclasses should
override this method to return a single <code class="xref py py-class docutils literal notranslate"><span class="pre">Target</span></code> or a list of
<code class="xref py py-class docutils literal notranslate"><span class="pre">Target</span></code> instances.</p>
<dl class="simple">
<dt>Implementation note</dt><dd><p>If running multiple workers, the output must be a resource that is accessible
by all workers, such as a DFS or database. Otherwise, workers might compute
the same output since they don’t see the work done by other workers.</p>
</dd>
</dl>
<p>See <span class="xref std std-ref">Task.output</span></p>
</dd></dl>

<dl class="py method">
<dt id="sv_callings.SVBreakdancer.run">
<code class="sig-name descname">run</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em><span class="sig-paren">)</span><a class="headerlink" href="#sv_callings.SVBreakdancer.run" title="Permalink to this definition">¶</a></dt>
<dd><p>The task run method, to be overridden in a subclass.</p>
<p>See <span class="xref std std-ref">Task.run</span></p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="sv_callings.SVTardis">
<em class="property">class </em><code class="sig-prename descclassname">sv_callings.</code><code class="sig-name descname">SVTardis</code><span class="sig-paren">(</span><em class="sig-param"><span class="o">*</span><span class="n">args</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="headerlink" href="#sv_callings.SVTardis" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-obj docutils literal notranslate"><span class="pre">luigi.Task</span></code></p>
<p>Class responsible for SV calling using Tardis.</p>
<dl class="py attribute">
<dt id="sv_callings.SVTardis.resources">
<code class="sig-name descname">resources</code><a class="headerlink" href="#sv_callings.SVTardis.resources" title="Permalink to this definition">¶</a></dt>
<dd><p>Resources used by the task.</p>
</dd></dl>

<dl class="py attribute">
<dt id="sv_callings.SVTardis.working_dir">
<code class="sig-name descname">working_dir</code><a class="headerlink" href="#sv_callings.SVTardis.working_dir" title="Permalink to this definition">¶</a></dt>
<dd><p>Working directory of the task.</p>
</dd></dl>

<dl class="py attribute">
<dt id="sv_callings.SVTardis.file_name_1">
<code class="sig-name descname">file_name_1</code><a class="headerlink" href="#sv_callings.SVTardis.file_name_1" title="Permalink to this definition">¶</a></dt>
<dd><p>Name of the file containing R1 reads.</p>
</dd></dl>

<dl class="py attribute">
<dt id="sv_callings.SVTardis.file_name_2">
<code class="sig-name descname">file_name_2</code><a class="headerlink" href="#sv_callings.SVTardis.file_name_2" title="Permalink to this definition">¶</a></dt>
<dd><p>Name of the file containing R2 reads.</p>
</dd></dl>

<dl class="py attribute">
<dt id="sv_callings.SVTardis.sample_name">
<code class="sig-name descname">sample_name</code><a class="headerlink" href="#sv_callings.SVTardis.sample_name" title="Permalink to this definition">¶</a></dt>
<dd><p>Name of the sample.</p>
</dd></dl>

<dl class="py attribute">
<dt id="sv_callings.SVTardis.train_1000g">
<code class="sig-name descname">train_1000g</code><a class="headerlink" href="#sv_callings.SVTardis.train_1000g" title="Permalink to this definition">¶</a></dt>
<dd><p>Information whether the current task is part of 1000G benchmarking pipeline.</p>
</dd></dl>

<dl class="py method">
<dt id="sv_callings.SVTardis.requires">
<code class="sig-name descname">requires</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em><span class="sig-paren">)</span><a class="headerlink" href="#sv_callings.SVTardis.requires" title="Permalink to this definition">¶</a></dt>
<dd><p>The Tasks that this Task depends on.</p>
<p>A Task will only run if all of the Tasks that it requires are completed.
If your Task does not require any other Tasks, then you don’t need to
override this method. Otherwise, a subclass can override this method
to return a single Task, a list of Task instances, or a dict whose
values are Task instances.</p>
<p>See <span class="xref std std-ref">Task.requires</span></p>
</dd></dl>

<dl class="py method">
<dt id="sv_callings.SVTardis.output">
<code class="sig-name descname">output</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em><span class="sig-paren">)</span><a class="headerlink" href="#sv_callings.SVTardis.output" title="Permalink to this definition">¶</a></dt>
<dd><p>The output that this Task produces.</p>
<p>The output of the Task determines if the Task needs to be run–the task
is considered finished iff the outputs all exist. Subclasses should
override this method to return a single <code class="xref py py-class docutils literal notranslate"><span class="pre">Target</span></code> or a list of
<code class="xref py py-class docutils literal notranslate"><span class="pre">Target</span></code> instances.</p>
<dl class="simple">
<dt>Implementation note</dt><dd><p>If running multiple workers, the output must be a resource that is accessible
by all workers, such as a DFS or database. Otherwise, workers might compute
the same output since they don’t see the work done by other workers.</p>
</dd>
</dl>
<p>See <span class="xref std std-ref">Task.output</span></p>
</dd></dl>

<dl class="py method">
<dt id="sv_callings.SVTardis.run">
<code class="sig-name descname">run</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em><span class="sig-paren">)</span><a class="headerlink" href="#sv_callings.SVTardis.run" title="Permalink to this definition">¶</a></dt>
<dd><p>The task run method, to be overridden in a subclass.</p>
<p>See <span class="xref std std-ref">Task.run</span></p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="sv_callings.SVNovoBreak">
<em class="property">class </em><code class="sig-prename descclassname">sv_callings.</code><code class="sig-name descname">SVNovoBreak</code><span class="sig-paren">(</span><em class="sig-param"><span class="o">*</span><span class="n">args</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="headerlink" href="#sv_callings.SVNovoBreak" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-obj docutils literal notranslate"><span class="pre">luigi.Task</span></code></p>
<p>Class responsible for SV calling using novoBreak. It is disabled in default run because of its computational time.</p>
<dl class="py attribute">
<dt id="sv_callings.SVNovoBreak.working_dir">
<code class="sig-name descname">working_dir</code><a class="headerlink" href="#sv_callings.SVNovoBreak.working_dir" title="Permalink to this definition">¶</a></dt>
<dd><p>Working directory of the task.</p>
</dd></dl>

<dl class="py attribute">
<dt id="sv_callings.SVNovoBreak.file_name_1">
<code class="sig-name descname">file_name_1</code><a class="headerlink" href="#sv_callings.SVNovoBreak.file_name_1" title="Permalink to this definition">¶</a></dt>
<dd><p>Name of the file containing R1 reads.</p>
</dd></dl>

<dl class="py attribute">
<dt id="sv_callings.SVNovoBreak.file_name_2">
<code class="sig-name descname">file_name_2</code><a class="headerlink" href="#sv_callings.SVNovoBreak.file_name_2" title="Permalink to this definition">¶</a></dt>
<dd><p>Name of the file containing R2 reads.</p>
</dd></dl>

<dl class="py attribute">
<dt id="sv_callings.SVNovoBreak.sample_name">
<code class="sig-name descname">sample_name</code><a class="headerlink" href="#sv_callings.SVNovoBreak.sample_name" title="Permalink to this definition">¶</a></dt>
<dd><p>Name of the sample.</p>
</dd></dl>

<dl class="py attribute">
<dt id="sv_callings.SVNovoBreak.train_1000g">
<code class="sig-name descname">train_1000g</code><a class="headerlink" href="#sv_callings.SVNovoBreak.train_1000g" title="Permalink to this definition">¶</a></dt>
<dd><p>Information whether the current task is part of 1000G benchmarking pipeline.</p>
</dd></dl>

<dl class="py method">
<dt id="sv_callings.SVNovoBreak.requires">
<code class="sig-name descname">requires</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em><span class="sig-paren">)</span><a class="headerlink" href="#sv_callings.SVNovoBreak.requires" title="Permalink to this definition">¶</a></dt>
<dd><p>The Tasks that this Task depends on.</p>
<p>A Task will only run if all of the Tasks that it requires are completed.
If your Task does not require any other Tasks, then you don’t need to
override this method. Otherwise, a subclass can override this method
to return a single Task, a list of Task instances, or a dict whose
values are Task instances.</p>
<p>See <span class="xref std std-ref">Task.requires</span></p>
</dd></dl>

<dl class="py method">
<dt id="sv_callings.SVNovoBreak.output">
<code class="sig-name descname">output</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em><span class="sig-paren">)</span><a class="headerlink" href="#sv_callings.SVNovoBreak.output" title="Permalink to this definition">¶</a></dt>
<dd><p>The output that this Task produces.</p>
<p>The output of the Task determines if the Task needs to be run–the task
is considered finished iff the outputs all exist. Subclasses should
override this method to return a single <code class="xref py py-class docutils literal notranslate"><span class="pre">Target</span></code> or a list of
<code class="xref py py-class docutils literal notranslate"><span class="pre">Target</span></code> instances.</p>
<dl class="simple">
<dt>Implementation note</dt><dd><p>If running multiple workers, the output must be a resource that is accessible
by all workers, such as a DFS or database. Otherwise, workers might compute
the same output since they don’t see the work done by other workers.</p>
</dd>
</dl>
<p>See <span class="xref std std-ref">Task.output</span></p>
</dd></dl>

<dl class="py method">
<dt id="sv_callings.SVNovoBreak.run">
<code class="sig-name descname">run</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em><span class="sig-paren">)</span><a class="headerlink" href="#sv_callings.SVNovoBreak.run" title="Permalink to this definition">¶</a></dt>
<dd><p>The task run method, to be overridden in a subclass.</p>
<p>See <span class="xref std std-ref">Task.run</span></p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="sv_callings.SVCNVNator">
<em class="property">class </em><code class="sig-prename descclassname">sv_callings.</code><code class="sig-name descname">SVCNVNator</code><span class="sig-paren">(</span><em class="sig-param"><span class="o">*</span><span class="n">args</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="headerlink" href="#sv_callings.SVCNVNator" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-obj docutils literal notranslate"><span class="pre">luigi.Task</span></code></p>
<p>Class responsible for SV calling using CNVNator.</p>
<dl class="py attribute">
<dt id="sv_callings.SVCNVNator.resources">
<code class="sig-name descname">resources</code><a class="headerlink" href="#sv_callings.SVCNVNator.resources" title="Permalink to this definition">¶</a></dt>
<dd><p>Resources used by the task.</p>
</dd></dl>

<dl class="py attribute">
<dt id="sv_callings.SVCNVNator.working_dir">
<code class="sig-name descname">working_dir</code><a class="headerlink" href="#sv_callings.SVCNVNator.working_dir" title="Permalink to this definition">¶</a></dt>
<dd><p>Working directory of the task.</p>
</dd></dl>

<dl class="py attribute">
<dt id="sv_callings.SVCNVNator.file_name_1">
<code class="sig-name descname">file_name_1</code><a class="headerlink" href="#sv_callings.SVCNVNator.file_name_1" title="Permalink to this definition">¶</a></dt>
<dd><p>Name of the file containing R1 reads.</p>
</dd></dl>

<dl class="py attribute">
<dt id="sv_callings.SVCNVNator.file_name_2">
<code class="sig-name descname">file_name_2</code><a class="headerlink" href="#sv_callings.SVCNVNator.file_name_2" title="Permalink to this definition">¶</a></dt>
<dd><p>Name of the file containing R2 reads.</p>
</dd></dl>

<dl class="py attribute">
<dt id="sv_callings.SVCNVNator.sample_name">
<code class="sig-name descname">sample_name</code><a class="headerlink" href="#sv_callings.SVCNVNator.sample_name" title="Permalink to this definition">¶</a></dt>
<dd><p>Name of the sample.</p>
</dd></dl>

<dl class="py attribute">
<dt id="sv_callings.SVCNVNator.train_1000g">
<code class="sig-name descname">train_1000g</code><a class="headerlink" href="#sv_callings.SVCNVNator.train_1000g" title="Permalink to this definition">¶</a></dt>
<dd><p>Information whether the current task is part of 1000G benchmarking pipeline.</p>
</dd></dl>

<dl class="py method">
<dt id="sv_callings.SVCNVNator.requires">
<code class="sig-name descname">requires</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em><span class="sig-paren">)</span><a class="headerlink" href="#sv_callings.SVCNVNator.requires" title="Permalink to this definition">¶</a></dt>
<dd><p>The Tasks that this Task depends on.</p>
<p>A Task will only run if all of the Tasks that it requires are completed.
If your Task does not require any other Tasks, then you don’t need to
override this method. Otherwise, a subclass can override this method
to return a single Task, a list of Task instances, or a dict whose
values are Task instances.</p>
<p>See <span class="xref std std-ref">Task.requires</span></p>
</dd></dl>

<dl class="py method">
<dt id="sv_callings.SVCNVNator.output">
<code class="sig-name descname">output</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em><span class="sig-paren">)</span><a class="headerlink" href="#sv_callings.SVCNVNator.output" title="Permalink to this definition">¶</a></dt>
<dd><p>The output that this Task produces.</p>
<p>The output of the Task determines if the Task needs to be run–the task
is considered finished iff the outputs all exist. Subclasses should
override this method to return a single <code class="xref py py-class docutils literal notranslate"><span class="pre">Target</span></code> or a list of
<code class="xref py py-class docutils literal notranslate"><span class="pre">Target</span></code> instances.</p>
<dl class="simple">
<dt>Implementation note</dt><dd><p>If running multiple workers, the output must be a resource that is accessible
by all workers, such as a DFS or database. Otherwise, workers might compute
the same output since they don’t see the work done by other workers.</p>
</dd>
</dl>
<p>See <span class="xref std std-ref">Task.output</span></p>
</dd></dl>

<dl class="py method">
<dt id="sv_callings.SVCNVNator.run">
<code class="sig-name descname">run</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em><span class="sig-paren">)</span><a class="headerlink" href="#sv_callings.SVCNVNator.run" title="Permalink to this definition">¶</a></dt>
<dd><p>The task run method, to be overridden in a subclass.</p>
<p>See <span class="xref std std-ref">Task.run</span></p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="sv_callings.SVBreakSeq">
<em class="property">class </em><code class="sig-prename descclassname">sv_callings.</code><code class="sig-name descname">SVBreakSeq</code><span class="sig-paren">(</span><em class="sig-param"><span class="o">*</span><span class="n">args</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="headerlink" href="#sv_callings.SVBreakSeq" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-obj docutils literal notranslate"><span class="pre">luigi.Task</span></code></p>
<p>Class responsible for SV calling using BreakSeq.</p>
<dl class="py attribute">
<dt id="sv_callings.SVBreakSeq.resources">
<code class="sig-name descname">resources</code><a class="headerlink" href="#sv_callings.SVBreakSeq.resources" title="Permalink to this definition">¶</a></dt>
<dd><p>Resources used by the task.</p>
</dd></dl>

<dl class="py attribute">
<dt id="sv_callings.SVBreakSeq.working_dir">
<code class="sig-name descname">working_dir</code><a class="headerlink" href="#sv_callings.SVBreakSeq.working_dir" title="Permalink to this definition">¶</a></dt>
<dd><p>Working directory of the task.</p>
</dd></dl>

<dl class="py attribute">
<dt id="sv_callings.SVBreakSeq.file_name_1">
<code class="sig-name descname">file_name_1</code><a class="headerlink" href="#sv_callings.SVBreakSeq.file_name_1" title="Permalink to this definition">¶</a></dt>
<dd><p>Name of the file containing R1 reads.</p>
</dd></dl>

<dl class="py attribute">
<dt id="sv_callings.SVBreakSeq.file_name_2">
<code class="sig-name descname">file_name_2</code><a class="headerlink" href="#sv_callings.SVBreakSeq.file_name_2" title="Permalink to this definition">¶</a></dt>
<dd><p>Name of the file containing R2 reads.</p>
</dd></dl>

<dl class="py attribute">
<dt id="sv_callings.SVBreakSeq.sample_name">
<code class="sig-name descname">sample_name</code><a class="headerlink" href="#sv_callings.SVBreakSeq.sample_name" title="Permalink to this definition">¶</a></dt>
<dd><p>Name of the sample.</p>
</dd></dl>

<dl class="py attribute">
<dt id="sv_callings.SVBreakSeq.train_1000g">
<code class="sig-name descname">train_1000g</code><a class="headerlink" href="#sv_callings.SVBreakSeq.train_1000g" title="Permalink to this definition">¶</a></dt>
<dd><p>Information whether the current task is part of 1000G benchmarking pipeline.</p>
</dd></dl>

<dl class="py method">
<dt id="sv_callings.SVBreakSeq.requires">
<code class="sig-name descname">requires</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em><span class="sig-paren">)</span><a class="headerlink" href="#sv_callings.SVBreakSeq.requires" title="Permalink to this definition">¶</a></dt>
<dd><p>The Tasks that this Task depends on.</p>
<p>A Task will only run if all of the Tasks that it requires are completed.
If your Task does not require any other Tasks, then you don’t need to
override this method. Otherwise, a subclass can override this method
to return a single Task, a list of Task instances, or a dict whose
values are Task instances.</p>
<p>See <span class="xref std std-ref">Task.requires</span></p>
</dd></dl>

<dl class="py method">
<dt id="sv_callings.SVBreakSeq.output">
<code class="sig-name descname">output</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em><span class="sig-paren">)</span><a class="headerlink" href="#sv_callings.SVBreakSeq.output" title="Permalink to this definition">¶</a></dt>
<dd><p>The output that this Task produces.</p>
<p>The output of the Task determines if the Task needs to be run–the task
is considered finished iff the outputs all exist. Subclasses should
override this method to return a single <code class="xref py py-class docutils literal notranslate"><span class="pre">Target</span></code> or a list of
<code class="xref py py-class docutils literal notranslate"><span class="pre">Target</span></code> instances.</p>
<dl class="simple">
<dt>Implementation note</dt><dd><p>If running multiple workers, the output must be a resource that is accessible
by all workers, such as a DFS or database. Otherwise, workers might compute
the same output since they don’t see the work done by other workers.</p>
</dd>
</dl>
<p>See <span class="xref std std-ref">Task.output</span></p>
</dd></dl>

<dl class="py method">
<dt id="sv_callings.SVBreakSeq.run">
<code class="sig-name descname">run</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em><span class="sig-paren">)</span><a class="headerlink" href="#sv_callings.SVBreakSeq.run" title="Permalink to this definition">¶</a></dt>
<dd><p>The task run method, to be overridden in a subclass.</p>
<p>See <span class="xref std std-ref">Task.run</span></p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="sv_callings.SVManta">
<em class="property">class </em><code class="sig-prename descclassname">sv_callings.</code><code class="sig-name descname">SVManta</code><span class="sig-paren">(</span><em class="sig-param"><span class="o">*</span><span class="n">args</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="headerlink" href="#sv_callings.SVManta" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-obj docutils literal notranslate"><span class="pre">luigi.Task</span></code></p>
<p>Class responsible for SV calling using Manta.</p>
<dl class="py attribute">
<dt id="sv_callings.SVManta.resources">
<code class="sig-name descname">resources</code><a class="headerlink" href="#sv_callings.SVManta.resources" title="Permalink to this definition">¶</a></dt>
<dd><p>Resources used by the task.</p>
</dd></dl>

<dl class="py attribute">
<dt id="sv_callings.SVManta.working_dir">
<code class="sig-name descname">working_dir</code><a class="headerlink" href="#sv_callings.SVManta.working_dir" title="Permalink to this definition">¶</a></dt>
<dd><p>Working directory of the task.</p>
</dd></dl>

<dl class="py attribute">
<dt id="sv_callings.SVManta.file_name_1">
<code class="sig-name descname">file_name_1</code><a class="headerlink" href="#sv_callings.SVManta.file_name_1" title="Permalink to this definition">¶</a></dt>
<dd><p>Name of the file containing R1 reads.</p>
</dd></dl>

<dl class="py attribute">
<dt id="sv_callings.SVManta.file_name_2">
<code class="sig-name descname">file_name_2</code><a class="headerlink" href="#sv_callings.SVManta.file_name_2" title="Permalink to this definition">¶</a></dt>
<dd><p>Name of the file containing R2 reads.</p>
</dd></dl>

<dl class="py attribute">
<dt id="sv_callings.SVManta.sample_name">
<code class="sig-name descname">sample_name</code><a class="headerlink" href="#sv_callings.SVManta.sample_name" title="Permalink to this definition">¶</a></dt>
<dd><p>Name of the sample.</p>
</dd></dl>

<dl class="py attribute">
<dt id="sv_callings.SVManta.train_1000g">
<code class="sig-name descname">train_1000g</code><a class="headerlink" href="#sv_callings.SVManta.train_1000g" title="Permalink to this definition">¶</a></dt>
<dd><p>Information whether the current task is part of 1000G benchmarking pipeline.</p>
</dd></dl>

<dl class="py method">
<dt id="sv_callings.SVManta.requires">
<code class="sig-name descname">requires</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em><span class="sig-paren">)</span><a class="headerlink" href="#sv_callings.SVManta.requires" title="Permalink to this definition">¶</a></dt>
<dd><p>The Tasks that this Task depends on.</p>
<p>A Task will only run if all of the Tasks that it requires are completed.
If your Task does not require any other Tasks, then you don’t need to
override this method. Otherwise, a subclass can override this method
to return a single Task, a list of Task instances, or a dict whose
values are Task instances.</p>
<p>See <span class="xref std std-ref">Task.requires</span></p>
</dd></dl>

<dl class="py method">
<dt id="sv_callings.SVManta.output">
<code class="sig-name descname">output</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em><span class="sig-paren">)</span><a class="headerlink" href="#sv_callings.SVManta.output" title="Permalink to this definition">¶</a></dt>
<dd><p>The output that this Task produces.</p>
<p>The output of the Task determines if the Task needs to be run–the task
is considered finished iff the outputs all exist. Subclasses should
override this method to return a single <code class="xref py py-class docutils literal notranslate"><span class="pre">Target</span></code> or a list of
<code class="xref py py-class docutils literal notranslate"><span class="pre">Target</span></code> instances.</p>
<dl class="simple">
<dt>Implementation note</dt><dd><p>If running multiple workers, the output must be a resource that is accessible
by all workers, such as a DFS or database. Otherwise, workers might compute
the same output since they don’t see the work done by other workers.</p>
</dd>
</dl>
<p>See <span class="xref std std-ref">Task.output</span></p>
</dd></dl>

<dl class="py method">
<dt id="sv_callings.SVManta.run">
<code class="sig-name descname">run</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em><span class="sig-paren">)</span><a class="headerlink" href="#sv_callings.SVManta.run" title="Permalink to this definition">¶</a></dt>
<dd><p>The task run method, to be overridden in a subclass.</p>
<p>See <span class="xref std std-ref">Task.run</span></p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="sv_callings.SVLumpy">
<em class="property">class </em><code class="sig-prename descclassname">sv_callings.</code><code class="sig-name descname">SVLumpy</code><span class="sig-paren">(</span><em class="sig-param"><span class="o">*</span><span class="n">args</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="headerlink" href="#sv_callings.SVLumpy" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-obj docutils literal notranslate"><span class="pre">luigi.Task</span></code></p>
<p>Class responsible for SV calling using Lumpy.</p>
<dl class="py attribute">
<dt id="sv_callings.SVLumpy.resources">
<code class="sig-name descname">resources</code><a class="headerlink" href="#sv_callings.SVLumpy.resources" title="Permalink to this definition">¶</a></dt>
<dd><p>Resources used by the task.</p>
</dd></dl>

<dl class="py attribute">
<dt id="sv_callings.SVLumpy.working_dir">
<code class="sig-name descname">working_dir</code><a class="headerlink" href="#sv_callings.SVLumpy.working_dir" title="Permalink to this definition">¶</a></dt>
<dd><p>Working directory of the task.</p>
</dd></dl>

<dl class="py attribute">
<dt id="sv_callings.SVLumpy.file_name_1">
<code class="sig-name descname">file_name_1</code><a class="headerlink" href="#sv_callings.SVLumpy.file_name_1" title="Permalink to this definition">¶</a></dt>
<dd><p>Name of the file containing R1 reads.</p>
</dd></dl>

<dl class="py attribute">
<dt id="sv_callings.SVLumpy.file_name_2">
<code class="sig-name descname">file_name_2</code><a class="headerlink" href="#sv_callings.SVLumpy.file_name_2" title="Permalink to this definition">¶</a></dt>
<dd><p>Name of the file containing R2 reads.</p>
</dd></dl>

<dl class="py attribute">
<dt id="sv_callings.SVLumpy.sample_name">
<code class="sig-name descname">sample_name</code><a class="headerlink" href="#sv_callings.SVLumpy.sample_name" title="Permalink to this definition">¶</a></dt>
<dd><p>Name of the sample.</p>
</dd></dl>

<dl class="py attribute">
<dt id="sv_callings.SVLumpy.train_1000g">
<code class="sig-name descname">train_1000g</code><a class="headerlink" href="#sv_callings.SVLumpy.train_1000g" title="Permalink to this definition">¶</a></dt>
<dd><p>Information whether the current task is part of 1000G benchmarking pipeline.</p>
</dd></dl>

<dl class="py method">
<dt id="sv_callings.SVLumpy.requires">
<code class="sig-name descname">requires</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em><span class="sig-paren">)</span><a class="headerlink" href="#sv_callings.SVLumpy.requires" title="Permalink to this definition">¶</a></dt>
<dd><p>The Tasks that this Task depends on.</p>
<p>A Task will only run if all of the Tasks that it requires are completed.
If your Task does not require any other Tasks, then you don’t need to
override this method. Otherwise, a subclass can override this method
to return a single Task, a list of Task instances, or a dict whose
values are Task instances.</p>
<p>See <span class="xref std std-ref">Task.requires</span></p>
</dd></dl>

<dl class="py method">
<dt id="sv_callings.SVLumpy.output">
<code class="sig-name descname">output</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em><span class="sig-paren">)</span><a class="headerlink" href="#sv_callings.SVLumpy.output" title="Permalink to this definition">¶</a></dt>
<dd><p>The output that this Task produces.</p>
<p>The output of the Task determines if the Task needs to be run–the task
is considered finished iff the outputs all exist. Subclasses should
override this method to return a single <code class="xref py py-class docutils literal notranslate"><span class="pre">Target</span></code> or a list of
<code class="xref py py-class docutils literal notranslate"><span class="pre">Target</span></code> instances.</p>
<dl class="simple">
<dt>Implementation note</dt><dd><p>If running multiple workers, the output must be a resource that is accessible
by all workers, such as a DFS or database. Otherwise, workers might compute
the same output since they don’t see the work done by other workers.</p>
</dd>
</dl>
<p>See <span class="xref std std-ref">Task.output</span></p>
</dd></dl>

<dl class="py method">
<dt id="sv_callings.SVLumpy.run">
<code class="sig-name descname">run</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em><span class="sig-paren">)</span><a class="headerlink" href="#sv_callings.SVLumpy.run" title="Permalink to this definition">¶</a></dt>
<dd><p>The task run method, to be overridden in a subclass.</p>
<p>See <span class="xref std std-ref">Task.run</span></p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="sv_callings.SVWhamg">
<em class="property">class </em><code class="sig-prename descclassname">sv_callings.</code><code class="sig-name descname">SVWhamg</code><span class="sig-paren">(</span><em class="sig-param"><span class="o">*</span><span class="n">args</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="headerlink" href="#sv_callings.SVWhamg" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-obj docutils literal notranslate"><span class="pre">luigi.Task</span></code></p>
<p>Class responsible for SV calling using Whamg.</p>
<dl class="py attribute">
<dt id="sv_callings.SVWhamg.resources">
<code class="sig-name descname">resources</code><a class="headerlink" href="#sv_callings.SVWhamg.resources" title="Permalink to this definition">¶</a></dt>
<dd><p>Resources used by the task.</p>
</dd></dl>

<dl class="py attribute">
<dt id="sv_callings.SVWhamg.working_dir">
<code class="sig-name descname">working_dir</code><a class="headerlink" href="#sv_callings.SVWhamg.working_dir" title="Permalink to this definition">¶</a></dt>
<dd><p>Working directory of the task.</p>
</dd></dl>

<dl class="py attribute">
<dt id="sv_callings.SVWhamg.file_name_1">
<code class="sig-name descname">file_name_1</code><a class="headerlink" href="#sv_callings.SVWhamg.file_name_1" title="Permalink to this definition">¶</a></dt>
<dd><p>Name of the file containing R1 reads.</p>
</dd></dl>

<dl class="py attribute">
<dt id="sv_callings.SVWhamg.file_name_2">
<code class="sig-name descname">file_name_2</code><a class="headerlink" href="#sv_callings.SVWhamg.file_name_2" title="Permalink to this definition">¶</a></dt>
<dd><p>Name of the file containing R2 reads.</p>
</dd></dl>

<dl class="py attribute">
<dt id="sv_callings.SVWhamg.sample_name">
<code class="sig-name descname">sample_name</code><a class="headerlink" href="#sv_callings.SVWhamg.sample_name" title="Permalink to this definition">¶</a></dt>
<dd><p>Name of the sample.</p>
</dd></dl>

<dl class="py attribute">
<dt id="sv_callings.SVWhamg.train_1000g">
<code class="sig-name descname">train_1000g</code><a class="headerlink" href="#sv_callings.SVWhamg.train_1000g" title="Permalink to this definition">¶</a></dt>
<dd><p>Information whether the current task is part of 1000G benchmarking pipeline.</p>
</dd></dl>

<dl class="py method">
<dt id="sv_callings.SVWhamg.requires">
<code class="sig-name descname">requires</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em><span class="sig-paren">)</span><a class="headerlink" href="#sv_callings.SVWhamg.requires" title="Permalink to this definition">¶</a></dt>
<dd><p>The Tasks that this Task depends on.</p>
<p>A Task will only run if all of the Tasks that it requires are completed.
If your Task does not require any other Tasks, then you don’t need to
override this method. Otherwise, a subclass can override this method
to return a single Task, a list of Task instances, or a dict whose
values are Task instances.</p>
<p>See <span class="xref std std-ref">Task.requires</span></p>
</dd></dl>

<dl class="py method">
<dt id="sv_callings.SVWhamg.output">
<code class="sig-name descname">output</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em><span class="sig-paren">)</span><a class="headerlink" href="#sv_callings.SVWhamg.output" title="Permalink to this definition">¶</a></dt>
<dd><p>The output that this Task produces.</p>
<p>The output of the Task determines if the Task needs to be run–the task
is considered finished iff the outputs all exist. Subclasses should
override this method to return a single <code class="xref py py-class docutils literal notranslate"><span class="pre">Target</span></code> or a list of
<code class="xref py py-class docutils literal notranslate"><span class="pre">Target</span></code> instances.</p>
<dl class="simple">
<dt>Implementation note</dt><dd><p>If running multiple workers, the output must be a resource that is accessible
by all workers, such as a DFS or database. Otherwise, workers might compute
the same output since they don’t see the work done by other workers.</p>
</dd>
</dl>
<p>See <span class="xref std std-ref">Task.output</span></p>
</dd></dl>

<dl class="py method">
<dt id="sv_callings.SVWhamg.run">
<code class="sig-name descname">run</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em><span class="sig-paren">)</span><a class="headerlink" href="#sv_callings.SVWhamg.run" title="Permalink to this definition">¶</a></dt>
<dd><p>The task run method, to be overridden in a subclass.</p>
<p>See <span class="xref std std-ref">Task.run</span></p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="sv_callings.SVSvelter">
<em class="property">class </em><code class="sig-prename descclassname">sv_callings.</code><code class="sig-name descname">SVSvelter</code><span class="sig-paren">(</span><em class="sig-param"><span class="o">*</span><span class="n">args</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="headerlink" href="#sv_callings.SVSvelter" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-obj docutils literal notranslate"><span class="pre">luigi.Task</span></code></p>
<p>Class responsible for SV calling using Svelter.</p>
<dl class="py attribute">
<dt id="sv_callings.SVSvelter.resources">
<code class="sig-name descname">resources</code><a class="headerlink" href="#sv_callings.SVSvelter.resources" title="Permalink to this definition">¶</a></dt>
<dd><p>Resources used by the task.</p>
</dd></dl>

<dl class="py attribute">
<dt id="sv_callings.SVSvelter.working_dir">
<code class="sig-name descname">working_dir</code><a class="headerlink" href="#sv_callings.SVSvelter.working_dir" title="Permalink to this definition">¶</a></dt>
<dd><p>Working directory of the task.</p>
</dd></dl>

<dl class="py attribute">
<dt id="sv_callings.SVSvelter.file_name_1">
<code class="sig-name descname">file_name_1</code><a class="headerlink" href="#sv_callings.SVSvelter.file_name_1" title="Permalink to this definition">¶</a></dt>
<dd><p>Name of the file containing R1 reads.</p>
</dd></dl>

<dl class="py attribute">
<dt id="sv_callings.SVSvelter.file_name_2">
<code class="sig-name descname">file_name_2</code><a class="headerlink" href="#sv_callings.SVSvelter.file_name_2" title="Permalink to this definition">¶</a></dt>
<dd><p>Name of the file containing R2 reads.</p>
</dd></dl>

<dl class="py attribute">
<dt id="sv_callings.SVSvelter.sample_name">
<code class="sig-name descname">sample_name</code><a class="headerlink" href="#sv_callings.SVSvelter.sample_name" title="Permalink to this definition">¶</a></dt>
<dd><p>Name of the sample.</p>
</dd></dl>

<dl class="py attribute">
<dt id="sv_callings.SVSvelter.train_1000g">
<code class="sig-name descname">train_1000g</code><a class="headerlink" href="#sv_callings.SVSvelter.train_1000g" title="Permalink to this definition">¶</a></dt>
<dd><p>Information whether the current task is part of 1000G benchmarking pipeline.</p>
</dd></dl>

<dl class="py method">
<dt id="sv_callings.SVSvelter.requires">
<code class="sig-name descname">requires</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em><span class="sig-paren">)</span><a class="headerlink" href="#sv_callings.SVSvelter.requires" title="Permalink to this definition">¶</a></dt>
<dd><p>The Tasks that this Task depends on.</p>
<p>A Task will only run if all of the Tasks that it requires are completed.
If your Task does not require any other Tasks, then you don’t need to
override this method. Otherwise, a subclass can override this method
to return a single Task, a list of Task instances, or a dict whose
values are Task instances.</p>
<p>See <span class="xref std std-ref">Task.requires</span></p>
</dd></dl>

<dl class="py method">
<dt id="sv_callings.SVSvelter.output">
<code class="sig-name descname">output</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em><span class="sig-paren">)</span><a class="headerlink" href="#sv_callings.SVSvelter.output" title="Permalink to this definition">¶</a></dt>
<dd><p>The output that this Task produces.</p>
<p>The output of the Task determines if the Task needs to be run–the task
is considered finished iff the outputs all exist. Subclasses should
override this method to return a single <code class="xref py py-class docutils literal notranslate"><span class="pre">Target</span></code> or a list of
<code class="xref py py-class docutils literal notranslate"><span class="pre">Target</span></code> instances.</p>
<dl class="simple">
<dt>Implementation note</dt><dd><p>If running multiple workers, the output must be a resource that is accessible
by all workers, such as a DFS or database. Otherwise, workers might compute
the same output since they don’t see the work done by other workers.</p>
</dd>
</dl>
<p>See <span class="xref std std-ref">Task.output</span></p>
</dd></dl>

<dl class="py method">
<dt id="sv_callings.SVSvelter.run">
<code class="sig-name descname">run</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em><span class="sig-paren">)</span><a class="headerlink" href="#sv_callings.SVSvelter.run" title="Permalink to this definition">¶</a></dt>
<dd><p>The task run method, to be overridden in a subclass.</p>
<p>See <span class="xref std std-ref">Task.run</span></p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="sv_callings.CallVariants">
<em class="property">class </em><code class="sig-prename descclassname">sv_callings.</code><code class="sig-name descname">CallVariants</code><span class="sig-paren">(</span><em class="sig-param"><span class="o">*</span><span class="n">args</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="headerlink" href="#sv_callings.CallVariants" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-obj docutils literal notranslate"><span class="pre">luigi.Task</span></code></p>
<p>Class responsible for calling variants using various methods.</p>
<dl class="py attribute">
<dt id="sv_callings.CallVariants.working_dir">
<code class="sig-name descname">working_dir</code><a class="headerlink" href="#sv_callings.CallVariants.working_dir" title="Permalink to this definition">¶</a></dt>
<dd><p>Working directory of the task.</p>
</dd></dl>

<dl class="py attribute">
<dt id="sv_callings.CallVariants.file_name_1">
<code class="sig-name descname">file_name_1</code><a class="headerlink" href="#sv_callings.CallVariants.file_name_1" title="Permalink to this definition">¶</a></dt>
<dd><p>Name of the file containing R1 reads.</p>
</dd></dl>

<dl class="py attribute">
<dt id="sv_callings.CallVariants.file_name_2">
<code class="sig-name descname">file_name_2</code><a class="headerlink" href="#sv_callings.CallVariants.file_name_2" title="Permalink to this definition">¶</a></dt>
<dd><p>Name of the file containing R2 reads.</p>
</dd></dl>

<dl class="py attribute">
<dt id="sv_callings.CallVariants.sample_name">
<code class="sig-name descname">sample_name</code><a class="headerlink" href="#sv_callings.CallVariants.sample_name" title="Permalink to this definition">¶</a></dt>
<dd><p>Name of the sample.</p>
</dd></dl>

<dl class="py attribute">
<dt id="sv_callings.CallVariants.train_1000g">
<code class="sig-name descname">train_1000g</code><a class="headerlink" href="#sv_callings.CallVariants.train_1000g" title="Permalink to this definition">¶</a></dt>
<dd><p>Information whether the current task is part of 1000G benchmarking pipeline.</p>
</dd></dl>

<dl class="py method">
<dt id="sv_callings.CallVariants.requires">
<code class="sig-name descname">requires</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em><span class="sig-paren">)</span><a class="headerlink" href="#sv_callings.CallVariants.requires" title="Permalink to this definition">¶</a></dt>
<dd><p>The Tasks that this Task depends on.</p>
<p>A Task will only run if all of the Tasks that it requires are completed.
If your Task does not require any other Tasks, then you don’t need to
override this method. Otherwise, a subclass can override this method
to return a single Task, a list of Task instances, or a dict whose
values are Task instances.</p>
<p>See <span class="xref std std-ref">Task.requires</span></p>
</dd></dl>

<dl class="py method">
<dt id="sv_callings.CallVariants.output">
<code class="sig-name descname">output</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em><span class="sig-paren">)</span><a class="headerlink" href="#sv_callings.CallVariants.output" title="Permalink to this definition">¶</a></dt>
<dd><p>The output that this Task produces.</p>
<p>The output of the Task determines if the Task needs to be run–the task
is considered finished iff the outputs all exist. Subclasses should
override this method to return a single <code class="xref py py-class docutils literal notranslate"><span class="pre">Target</span></code> or a list of
<code class="xref py py-class docutils literal notranslate"><span class="pre">Target</span></code> instances.</p>
<dl class="simple">
<dt>Implementation note</dt><dd><p>If running multiple workers, the output must be a resource that is accessible
by all workers, such as a DFS or database. Otherwise, workers might compute
the same output since they don’t see the work done by other workers.</p>
</dd>
</dl>
<p>See <span class="xref std std-ref">Task.output</span></p>
</dd></dl>

<dl class="py method">
<dt id="sv_callings.CallVariants.run">
<code class="sig-name descname">run</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em><span class="sig-paren">)</span><a class="headerlink" href="#sv_callings.CallVariants.run" title="Permalink to this definition">¶</a></dt>
<dd><p>The task run method, to be overridden in a subclass.</p>
<p>See <span class="xref std std-ref">Task.run</span></p>
</dd></dl>

</dd></dl>

</div>
</div>
</div>


           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2022, Mateusz Chiliński, Dariusz Plewczynski.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>